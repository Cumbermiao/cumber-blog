
---
title: 冒泡排序、选择排序
date: 2019-05-09 18:05:06
---

## 冒泡排序
冒泡排序步骤如下：
- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

> 冒泡排序在所有排序算法中最简单， 但是一般情况下其排序时间较长， 而且排序成功的时间根据原始顺序的排列不确定，只会在最大时间复杂度和最小时间复杂度之间。

由于冒泡排序每次都会将所剩元素中的最大值排到最后， 所以我们可以在内循环中取消比较最后已经排好的元素。

```js 
class ArrayList{
  constructor(arr){
    this.arr = arr;
  }
  swap(idx1,idx2){
    let temp = this.arr[idx1];
    this.arr[idx1] = this.arr[idx2];
    this.arr[idx2] = temp;
  }
  toString(){
    return this.arr.join(',');
  }
}
class Bubble extends ArrayList{
  constructor(arr){
    super(arr);
  }

  sort(){
    for(let i = 0;i<this.arr.length;i++){
      for(let j = 0;j<this.arr.length-1;j++){
        if(this.arr[j]>this.arr[j+1]){
          this.swap(j,j+1);
        }
      }
    }
  }

  
}
```

## 选择排序
> 选择排序每次循环找到最小的一个元素，将其与第一个元素调换位置， 每次循环只确定一个元素的位置， 其时间复杂度和冒泡一样都是 O(n<sup>2</sup>)。

此处需要注意 内循环中的判断条件 `let j=i;j<this.arr.length;` ， 首先 `j=i` 因为每次外循环之后都会排好一个 最小的数， 所以之前排好序的数不需要再重新比较。
`j<this.arr.length` this.arr.length 其实是每次内循环需要比较的次数(即所有未排序的元素的个数，包含自己)。
```js
class Selection{
  constructor(arr){
    super(arr);
  }

  sort(){
    let minIdx;
    for(let i=0;i<this.arr.length-1;i++){
      minIdx = i;
      for(let j=i;j<this.arr.length;j++){
        if(this.arr[j]>this.arr[i]){
          minIdx = j
        }
      }
      if(minIdx != i)this.swap(i,j);
    }
  }
}
```
---
title: js中的类型与类型转换
date: 2019-06-27 16:36:06
---

### 数据类型
- 基础数据类型: Boolean Null Undefined Number String Symbol BigInt
- 引用数据类型: Object
原本以为基础类型只用 6 中， 在 mdn 上面看了之后发现还有个 BigInt 类型， BigInt 是个什么东西呢？ 看看 mdn 上的介绍。
> The BigInt type is a new numeric primitive in JavaScript that can represent integers with arbitrary precision. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers. A BigInt is created by appending n to the end of the integer or by calling the constructor.

原来 BigInt 也是一个数字类型， 但是不同的是这个类型的可以操作存储超过安全限制的整数。 什么叫超过安全限制的整数?
Number 有一个 `MAX_SAFE_INTEGER` 属性， 看来 Number 类型的整数如果超过这个限制的时候存储和操作的时候可能就会发生数据丢失之类的。
那么 BigInt 怎么声明呢？ 很简单在数字后面加个n就行 ， 如 ```let a = 1n```, 声明的 a 就是一个BigInt 类型， 值就是1。


### 类型转换
日常中我们经常需要转换成的类型一般为 String , Boolean , Number 。 下面我们来看下转换规则。


#### 转成 String 类型
> 如何将其他类型转成 String 类型呢？ js 内置 String() 函数可将其他基础类型转成字符串，如`String(10) => '10'` , `Number('10') => 10`，这应该也是 js 类型转换所默认调用的方法。 当然还有其他方法可以转成字符串，除了 null, undefined 以及 Number 类型 ， 其他类型应该都能调用 toString 转成字符串。
- Number 转 String : `NaN => 'NaN'` , `1 => '1'` , `1e21 => '1e+21'`
- BigInt 转 String : `1n => '1'`
- Boolean 转 String : `true => 'true'` , `false => 'false'`
- null 转 String : `null => 'null'`
- undefined 转 String : `undefined => 'undefined'`
- Array 转 String : `[1,2,3] => '1,2,3'`
- Object 转 String : `{a:1} => '[object Object]'`


#### 转成 Number 类型
> 与转 String 类型一样， 转成 Number 类型也只需要用 Number() 函数。
- String 转 Number : `'' => 0` , `'123' => 123` , `'1e3' => 1000` , `'1a' => NaN` , `'1n' => NaN`
- BigInt 转 Number : ` 1n => 1`
- Boolean 转 Number : `true => 1` , `false => 0`
- undefined 转 Number : `undefined => NaN`
- null 转 Number : `null => 0`

#### 转 Boolean 类型
> 使用 Boolean() 进行 Boolean 类型转换
- 转成 false : undefined , null , +0 , -0 , NaN , "" ,
- 转成 true : 逻辑上除了上面的情况其他的应该都是真值

#### ToPrimitive
对于引用类型的对象在类型转换时使用 toPrimitive 转换， toPrimitive 的处理逻辑：
先检查对象是否有 valueOf 方法， 如果存在并且返回了基本类型的值，则使用返回值进行类型转换。
如果没有 valueOf ，则检查是否存在 toString 方法， 如果存在且返回类基础类型的值， 则使用返回值进行类型转换。 
如果以上条件都不符合， 那么返回 TypeError 错误。

es5 中可以使用 `Object.create(null)` 来创建一个不带 `__proto__` 的对象, 那么该对象就没有 toString 和 valueOf 方法， 如果该对象进行类型转换就会报错。
```js
var a = Object.create(null);
String(a); //Uncaught TypeError: Cannot convert object to primitive value
Number(a); //Uncaught TypeError: Cannot convert object to primitive value
```

### 转换规则场景

#### 转成 String 类型
- 当字符串 + 另一个类型时， 另一个类型会转成字符类型。
```js
var a = {
  valueOf:()=>10
}
'10'+a // '1010'

'10'+10 //'1010'

'10'+[10,10] //'1010,10'
```

#### 转成 Number 类型
- 有加法运算符，但是无String类型的时候，都会优先转换为Number类型
```js
true + true //2
true + 0 //1
```
- 除了加法运算， 其他运算都会自动转成Number 类型 , 需要注意的是 ==null 转成Number 为0 ， undefined 转成Number 为 NaN==
```js
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```

#### Symbol 的转换坑
ES6 中引入了 Symbol 类型， 其有个奇怪的地方 Symbol 类型可以使用 String() 显式的转成字符串， 但是在进行隐式转换时会报错.
按照以上总结的， Symbol 为基础类型， 使用 String() 转成字符串， 实际情况是可以的， 但是在隐式转换发生了 TypeError 的错误。
```js
var a = Symbol('aaa');
String(a);//"Symbol(aaa)"
a.valueOf(); //Symbol(aaa)
' '+a;//Uncaught TypeError: Cannot convert a Symbol value to a string
```

## 转换规则

每个操作符的隐式转换规则参考[文章](https://www.cnblogs.com/Juphy/p/7085197.html)

### + 操作符
- 一个操作数为 NaN ， 结果为 NaN
- Infinity+Infinity ， 结果是 Infinity
- Infinity+(-Infinity) ， 结果是 NaN
- 一个操作数为字符串， 另一个操作数会被转成字符串

###  乘除、减号运算符、取模运算符

如果操作数不是数值，则被隐式调用Number()函数进行转换

### 逻辑操作符 (! && ||)

- ! 使用 Boolean() 将操作符转成布尔值后求反。
- && 如果有一个操作数不是布尔值， 遵循以下规则：
  - 如果第一个操作数经过 Boolean() 之后为 true ， 则返回第二个操作数
  - 如果有一个操作数为 null， 返回 null
  - 如果有一个操作数为 NaN，返回 NaN
  - 如果有一个操作数为 undefined ， 返回 undefined
- || 处理逻辑与 && 类似

### 关系操作符 (< > <= >=)

- 两个操作数都为数值， 进行数值比较
- 都是字符串， 比较字符串的字符编码值
- 有一个为数值， 将另一个转换为数值， 进行数值比较
- 有一个为对象时， 调用 toPrimitive 方法
- 有一个为布尔值， 将其转换成数值
- NaN 与任何比较都为 false

### 相等操作符 ==
- 如果有一个为布尔值， 将其转换为数值
- 如果有一个为字符串， 另一个为数值， 将字符串转为数值
- null == undefined
- NaN 返回false
- 两个都为对象时， 比较两个操作数的指向
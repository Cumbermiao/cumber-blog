---
title: 跨域
date: 2019-07-24 17:24:58
---

今天在工作时遇到一个问题， 本地开发环境上传附件时一直报跨域错误， 最终问题是在本地 host 虽然配置了对于开发环境的上传应用的地址， 但是并没有起效， 而是使用了之前配置正式环境的地址。 尽管这次的问题源头不是跨域， 但是在解决问题中发现自己对于跨域了解的还是不够多， 决定深入了解下。

## 同源策略 The same-origin policy

> 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要==安全机制==。

以上是 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) 对于同源策略的定义， 首先我们要了解到同源策略是一种安全机制， 也是发生跨越问题的根本原因， 那么所谓的跨域手段其实是绕过该安全机制的方法。


#### IE

同源策略是浏览器搞出来的东西，每个浏览器尝试所实现的功能细节可能会有差异，但基本上整体功能上基本一致。既然有差异，那么差异较大的会是谁呢？对的，没错，就是 IE。

IE 主要有两点不一致：
- 授信范围: 两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。
- 端口：IE 未将端口号加入到同源策略的组成部分之中，因此 `http://company.com:81/index.html` 和 `http://company.com/index.html`  属于同源并且不受任何限制。

#### 什么叫同源？

只有当 协议+域名+端口 都相同时才是同源。同源策略除了作用于 http/https 还可以作用于其他协议如在浏览器打开本地文件使用的 file 协议， 还有 XSLT, XBL 等。
要注意以上的域名指定的不仅仅是一级域名， 不管是几级域名， 只要不一样都会被同源策略所监控。


下面给出与 ```http://www.google.com/index.html``` 是否同源的比较：
URL | 是否同源
-- | :--: |
 ```http://www.google.com/page/test.html``` | 是 
 ```https://www.google.com/index.html``` | 否 
 ```https://pic.google.com/index.html``` | 否 
 ```https://pic.google.com:8080/index.html``` | 否 

#### 同源策略的作用范围

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 无法获得
- ajax 请求无法发送

以上三点就是在同源策略限制下的结果。

## 跨域操作
> 同源策略虽然提高了浏览器的安全性， 但是在某些情况下我们是需要进行跨域操作的， 那么一下就解答对于上面的情况如何进行跨域操作。

### cookie
`cookie` 对于很多公司来说都是一种读取你浏览记录的一种手段， 如百度是会根据你的搜索记录推荐不同的广告， 不仅仅是在百度搜索里面， 就算在百科里也是推荐相同的广告。百科和搜索是两个不同的域名， 如何做到访问各自的 `cookie` 呢？

#### document.domain
之前参考阮一峰老师的文章通过设置`document.domain`进行跨域访问， 之前是可以的， 但现在发现该方法已经没用了， 只是在 chrome 中测试了一下， chrome 版本为 75.0.3770.142 。 有兴趣的同学可以试试是否是浏览器版本的原因。
原理是浏览器允许通过设置 `document.domain` 来共享`cookie`， 如果一级域名相同在各自域中设置 `document.domain` 为一级域名就可以共享。 
<!-- 前提是 ==两个地址的一级域名相同，只是二级域名不同。 -->

#### 设置 cookie 的 domain
翻查了一下 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie)上 `cookie` 的方法， 发现在设置 `cookie` 的时候还可以设置一些其他的参数: `path`, `domain`, `max-age`, `expires`, `secure`。 

其中有一个 `domain` 的参数， 实际操作了一下， 在`www.test.com` 中添加 `cookie` 时配置 `domain` 为 `test.com` , 在`buyer.test.com` 中就能访问该 `cookie`。我还试了一下三级域名`a.buyer.test.com`, `b.buyer.test.com` ， 结果只要设置的 `domain` 为 `test.com` 不管几级域名都能拿到该 `domain` 的 `cookie`。

如果`cookie`没有设置 `domain` , 默认为当前的域名， 其他域名无法获取。

浏览器中`Application` 中 `cookie` 显示的格式如下:
 Name | Value | Domain | Path | Expires/Max-Age | Size | HTTP | Secure | SameSite
 -- | -- | -- | -- | -- | -- | -- | -- | -- |
 `www.test.com` | `from%20www.test.com` | `.test.com` | / | `2019-07-24T13:29:58.609Z` | 31 | | |

### postMessage
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) 上 `postMessage` 的语法为：
```
otherWindow.postMessage(message, targetOrigin, [transfer]);
```
其中 `targetOrigin` 为接收源， 对于 `otherWindow` 给出的解释为：
> 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。
简单来说就是`Window`对象，如 `window`, `window.parent`,`window.iframe`等， 还有就是 `message` 事件中的 `event.source` 也是一个 `Window` 对象。

`postMessage`是如何实际使用的呢？
我刚开始测试使用的时候会遇到一些问题， 总结下来就是往接收源发送消息时首先你要拿到接收源的`Window`对象， 拿到对象之后就可以使用`postMessage`发送， 需要注意的 `Window` 对象的源需要和 `targetOrigin` 一致， 不一致就会报源不匹配的错误：
`(index):24 Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://seller.test.com') does not match the recipient window's origin ('http://www.test.com').`

其实按照我的理解语法应该改为 `targetWindow.postMessage(message, targetOrigin, [transfer])` 更容易理解一点。

按照上面的方法，两个源之间既然可以通信了， 那么你发送的消息是由你自己来定的， `cookie`, `storage`, `DOM`, `IndexDB`等， 只要能够转成字符串的都可以发送。


### 接口跨域

接口跨域应该是最常见的情况了， 在现在这种前后端分离的开发方式下， 前端同学在调用异步请求时就会出现不同源的情况， 特别是多个后端应用的情况下，这种情况经常会发生跨域。
下面就介绍一下如何处理异步请求的跨域。

#### 代理
代理应该是前后端分离开发用来处理跨域最常用的手段了。现在我们假设一种情况，你使用`webpack`或者其他构建共建搭建了一个前端服务，在没有配置 `host` 的情况下， 前端服务的源为 `http://localhost:port` 这种结构， 现在你要请求源为`http://192.168.26.99:8080`的后台服务的接口， 这必然会发生跨域问题。

使用代理服务时，你发送异步请求时的请求源仍然是当前前端服务的源，所以不会发生跨域， 代理服务会在监听到如 `/interface` 这种自定义前缀的时候会转发给后台服务。

#### JSONP
`JSONP` 应该是老生常谈的方法了，很多人也应该知道其实现原理，下面也稍微讲一下实现原理。
在 `html` 中有一些标签是可以跨域访问资源的， 如`script`,`iframe`,`image`等， 基本上所有带这种 `src` 的标签都可以用来跨域访问。

#### CORS
> 全称:"跨域资源共享"（Cross-origin resource sharing）

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

##### 简单请求与非简单请求
浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 
只要同时满足以下两大条件，就属于简单请求。
1. 请求方法为 HEAD, GET, POST 之一。
2. HTTP 请求头信息不超过以下几种字段:
    - Accept
    - Accept-Language
    - Content-Language
    - Last-Event-ID
    - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain。

而那些不满足上面两个条件的即是非简单请求。

##### 那么这两种请求之间有什么区别呢？
对于 `简单请求` , 浏览器会直接发起 `CORS` 请求， 然后根据服务器返回请求头中 `Access-Control-Allow-Origin` 是否包含发起请求的源， 不包含则会报跨域错误。

对于 `非简单请求` , 浏览器会发起一个预请求， 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。


##### 请求头与响应头
- 对于简单请求来说， 一般只要设置 `Access-Control-Allow-Origin` 即可， 对于后台服务来说不是设置多个值， 而是判断当前的源是否在允许的数组之内， 如果在则设置`Access-Control-Allow-Origin`为对应的源， 否则不设置即可。

- 对于非简单的请求来说就需要根据请求头里面的多个字段来判断了， 首先浏览器会发起一个预请求， 预请求中的方法为`OPTIONS`， 所以后台服务需要在 `OPTIONS` 中来设置一下对应的响应头。第一个 `Access-Control-Allow-Origin` 肯定是要设置的 ； 第二个 `Access-Control-Request-Methods` 需要设置允许跨域的方法； 第三个 `Access-Control-Request-Headers` 设置响应头头中允许的字段， 如 `content-type`，`token`等， 可以根据请求头中`access-control-request-headers`来设置。
另外如果需要携带 `cookie` ， 那么客户端需要设置一下 `xhr.withCredentials =true`，服务端也需要设置`Access-Control-Allow-Credentials=true`。
对于预请求服务端可以通过`Access-Control-Max-Age`设置对于的有效时间。

## 面试如何解答跨域问题

很多同学在被问到跨域问题的时候，脑子里总是浮现出 ajax 请求跨域， 这种想法是比较片面的。   

面试的时候在被问到跨域问题的时候，首先是解释一下同源策略， 再讲一下同源策略所限制的内容， 之后再讲一下对于 cookie, DOM, ajax 的跨域问题的解决方法。如果面试官稍微严一点，我们还可以讲一下同源策略所带来的安全性。

以上所有代码实践均在[github](https://github.com/Cumbermiao/interview)。